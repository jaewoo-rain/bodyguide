// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MyEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mock,
    required TResult Function() refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mock,
    TResult? Function()? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mock,
    TResult Function()? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_mock value) mock,
    required TResult Function(_refresh value) refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_mock value)? mock,
    TResult? Function(_refresh value)? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_mock value)? mock,
    TResult Function(_refresh value)? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyEventCopyWith<$Res> {
  factory $MyEventCopyWith(MyEvent value, $Res Function(MyEvent) then) =
      _$MyEventCopyWithImpl<$Res, MyEvent>;
}

/// @nodoc
class _$MyEventCopyWithImpl<$Res, $Val extends MyEvent>
    implements $MyEventCopyWith<$Res> {
  _$MyEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MyEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$mockImplCopyWith<$Res> {
  factory _$$mockImplCopyWith(
          _$mockImpl value, $Res Function(_$mockImpl) then) =
      __$$mockImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$mockImplCopyWithImpl<$Res>
    extends _$MyEventCopyWithImpl<$Res, _$mockImpl>
    implements _$$mockImplCopyWith<$Res> {
  __$$mockImplCopyWithImpl(_$mockImpl _value, $Res Function(_$mockImpl) _then)
      : super(_value, _then);

  /// Create a copy of MyEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$mockImpl implements _mock {
  const _$mockImpl();

  @override
  String toString() {
    return 'MyEvent.mock()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$mockImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mock,
    required TResult Function() refresh,
  }) {
    return mock();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mock,
    TResult? Function()? refresh,
  }) {
    return mock?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mock,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (mock != null) {
      return mock();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_mock value) mock,
    required TResult Function(_refresh value) refresh,
  }) {
    return mock(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_mock value)? mock,
    TResult? Function(_refresh value)? refresh,
  }) {
    return mock?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_mock value)? mock,
    TResult Function(_refresh value)? refresh,
    required TResult orElse(),
  }) {
    if (mock != null) {
      return mock(this);
    }
    return orElse();
  }
}

abstract class _mock implements MyEvent {
  const factory _mock() = _$mockImpl;
}

/// @nodoc
abstract class _$$refreshImplCopyWith<$Res> {
  factory _$$refreshImplCopyWith(
          _$refreshImpl value, $Res Function(_$refreshImpl) then) =
      __$$refreshImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$refreshImplCopyWithImpl<$Res>
    extends _$MyEventCopyWithImpl<$Res, _$refreshImpl>
    implements _$$refreshImplCopyWith<$Res> {
  __$$refreshImplCopyWithImpl(
      _$refreshImpl _value, $Res Function(_$refreshImpl) _then)
      : super(_value, _then);

  /// Create a copy of MyEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$refreshImpl implements _refresh {
  const _$refreshImpl();

  @override
  String toString() {
    return 'MyEvent.refresh()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$refreshImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() mock,
    required TResult Function() refresh,
  }) {
    return refresh();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? mock,
    TResult? Function()? refresh,
  }) {
    return refresh?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? mock,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_mock value) mock,
    required TResult Function(_refresh value) refresh,
  }) {
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_mock value)? mock,
    TResult? Function(_refresh value)? refresh,
  }) {
    return refresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_mock value)? mock,
    TResult Function(_refresh value)? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class _refresh implements MyEvent {
  const factory _refresh() = _$refreshImpl;
}

/// @nodoc
mixin _$MyState {
  bool get mock => throw _privateConstructorUsedError;
  Map<String, dynamic> get userProfile => throw _privateConstructorUsedError;
  Map<String, dynamic> get activityProfile =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> get exercisePerformance =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> get expProfile => throw _privateConstructorUsedError;

  /// Create a copy of MyState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MyStateCopyWith<MyState> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyStateCopyWith<$Res> {
  factory $MyStateCopyWith(MyState value, $Res Function(MyState) then) =
      _$MyStateCopyWithImpl<$Res, MyState>;
  @useResult
  $Res call(
      {bool mock,
      Map<String, dynamic> userProfile,
      Map<String, dynamic> activityProfile,
      Map<String, dynamic> exercisePerformance,
      Map<String, dynamic> expProfile});
}

/// @nodoc
class _$MyStateCopyWithImpl<$Res, $Val extends MyState>
    implements $MyStateCopyWith<$Res> {
  _$MyStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MyState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mock = null,
    Object? userProfile = null,
    Object? activityProfile = null,
    Object? exercisePerformance = null,
    Object? expProfile = null,
  }) {
    return _then(_value.copyWith(
      mock: null == mock
          ? _value.mock
          : mock // ignore: cast_nullable_to_non_nullable
              as bool,
      userProfile: null == userProfile
          ? _value.userProfile
          : userProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      activityProfile: null == activityProfile
          ? _value.activityProfile
          : activityProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      exercisePerformance: null == exercisePerformance
          ? _value.exercisePerformance
          : exercisePerformance // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      expProfile: null == expProfile
          ? _value.expProfile
          : expProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$MyStateImplCopyWith<$Res> implements $MyStateCopyWith<$Res> {
  factory _$$MyStateImplCopyWith(
          _$MyStateImpl value, $Res Function(_$MyStateImpl) then) =
      __$$MyStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {bool mock,
      Map<String, dynamic> userProfile,
      Map<String, dynamic> activityProfile,
      Map<String, dynamic> exercisePerformance,
      Map<String, dynamic> expProfile});
}

/// @nodoc
class __$$MyStateImplCopyWithImpl<$Res>
    extends _$MyStateCopyWithImpl<$Res, _$MyStateImpl>
    implements _$$MyStateImplCopyWith<$Res> {
  __$$MyStateImplCopyWithImpl(
      _$MyStateImpl _value, $Res Function(_$MyStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of MyState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? mock = null,
    Object? userProfile = null,
    Object? activityProfile = null,
    Object? exercisePerformance = null,
    Object? expProfile = null,
  }) {
    return _then(_$MyStateImpl(
      mock: null == mock
          ? _value.mock
          : mock // ignore: cast_nullable_to_non_nullable
              as bool,
      userProfile: null == userProfile
          ? _value._userProfile
          : userProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      activityProfile: null == activityProfile
          ? _value._activityProfile
          : activityProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      exercisePerformance: null == exercisePerformance
          ? _value._exercisePerformance
          : exercisePerformance // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      expProfile: null == expProfile
          ? _value._expProfile
          : expProfile // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
    ));
  }
}

/// @nodoc

class _$MyStateImpl implements _MyState {
  const _$MyStateImpl(
      {this.mock = false,
      final Map<String, dynamic> userProfile = const {},
      final Map<String, dynamic> activityProfile = const {},
      final Map<String, dynamic> exercisePerformance = const {},
      final Map<String, dynamic> expProfile = const {}})
      : _userProfile = userProfile,
        _activityProfile = activityProfile,
        _exercisePerformance = exercisePerformance,
        _expProfile = expProfile;

  @override
  @JsonKey()
  final bool mock;
  final Map<String, dynamic> _userProfile;
  @override
  @JsonKey()
  Map<String, dynamic> get userProfile {
    if (_userProfile is EqualUnmodifiableMapView) return _userProfile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_userProfile);
  }

  final Map<String, dynamic> _activityProfile;
  @override
  @JsonKey()
  Map<String, dynamic> get activityProfile {
    if (_activityProfile is EqualUnmodifiableMapView) return _activityProfile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_activityProfile);
  }

  final Map<String, dynamic> _exercisePerformance;
  @override
  @JsonKey()
  Map<String, dynamic> get exercisePerformance {
    if (_exercisePerformance is EqualUnmodifiableMapView)
      return _exercisePerformance;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_exercisePerformance);
  }

  final Map<String, dynamic> _expProfile;
  @override
  @JsonKey()
  Map<String, dynamic> get expProfile {
    if (_expProfile is EqualUnmodifiableMapView) return _expProfile;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_expProfile);
  }

  @override
  String toString() {
    return 'MyState(mock: $mock, userProfile: $userProfile, activityProfile: $activityProfile, exercisePerformance: $exercisePerformance, expProfile: $expProfile)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyStateImpl &&
            (identical(other.mock, mock) || other.mock == mock) &&
            const DeepCollectionEquality()
                .equals(other._userProfile, _userProfile) &&
            const DeepCollectionEquality()
                .equals(other._activityProfile, _activityProfile) &&
            const DeepCollectionEquality()
                .equals(other._exercisePerformance, _exercisePerformance) &&
            const DeepCollectionEquality()
                .equals(other._expProfile, _expProfile));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      mock,
      const DeepCollectionEquality().hash(_userProfile),
      const DeepCollectionEquality().hash(_activityProfile),
      const DeepCollectionEquality().hash(_exercisePerformance),
      const DeepCollectionEquality().hash(_expProfile));

  /// Create a copy of MyState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MyStateImplCopyWith<_$MyStateImpl> get copyWith =>
      __$$MyStateImplCopyWithImpl<_$MyStateImpl>(this, _$identity);
}

abstract class _MyState implements MyState {
  const factory _MyState(
      {final bool mock,
      final Map<String, dynamic> userProfile,
      final Map<String, dynamic> activityProfile,
      final Map<String, dynamic> exercisePerformance,
      final Map<String, dynamic> expProfile}) = _$MyStateImpl;

  @override
  bool get mock;
  @override
  Map<String, dynamic> get userProfile;
  @override
  Map<String, dynamic> get activityProfile;
  @override
  Map<String, dynamic> get exercisePerformance;
  @override
  Map<String, dynamic> get expProfile;

  /// Create a copy of MyState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MyStateImplCopyWith<_$MyStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
