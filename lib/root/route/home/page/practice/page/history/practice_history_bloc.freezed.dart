// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'practice_history_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$PracticeHistoryEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPracticeRecord,
    required TResult Function() refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadPracticeRecord,
    TResult? Function()? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPracticeRecord,
    TResult Function()? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadPracticeRecord value) loadPracticeRecord,
    required TResult Function(_refresh value) refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadPracticeRecord value)? loadPracticeRecord,
    TResult? Function(_refresh value)? refresh,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadPracticeRecord value)? loadPracticeRecord,
    TResult Function(_refresh value)? refresh,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeHistoryEventCopyWith<$Res> {
  factory $PracticeHistoryEventCopyWith(PracticeHistoryEvent value,
          $Res Function(PracticeHistoryEvent) then) =
      _$PracticeHistoryEventCopyWithImpl<$Res, PracticeHistoryEvent>;
}

/// @nodoc
class _$PracticeHistoryEventCopyWithImpl<$Res,
        $Val extends PracticeHistoryEvent>
    implements $PracticeHistoryEventCopyWith<$Res> {
  _$PracticeHistoryEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticeHistoryEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadPracticeRecordImplCopyWith<$Res> {
  factory _$$LoadPracticeRecordImplCopyWith(_$LoadPracticeRecordImpl value,
          $Res Function(_$LoadPracticeRecordImpl) then) =
      __$$LoadPracticeRecordImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadPracticeRecordImplCopyWithImpl<$Res>
    extends _$PracticeHistoryEventCopyWithImpl<$Res, _$LoadPracticeRecordImpl>
    implements _$$LoadPracticeRecordImplCopyWith<$Res> {
  __$$LoadPracticeRecordImplCopyWithImpl(_$LoadPracticeRecordImpl _value,
      $Res Function(_$LoadPracticeRecordImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeHistoryEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadPracticeRecordImpl implements _LoadPracticeRecord {
  const _$LoadPracticeRecordImpl();

  @override
  String toString() {
    return 'PracticeHistoryEvent.loadPracticeRecord()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadPracticeRecordImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPracticeRecord,
    required TResult Function() refresh,
  }) {
    return loadPracticeRecord();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadPracticeRecord,
    TResult? Function()? refresh,
  }) {
    return loadPracticeRecord?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPracticeRecord,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (loadPracticeRecord != null) {
      return loadPracticeRecord();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadPracticeRecord value) loadPracticeRecord,
    required TResult Function(_refresh value) refresh,
  }) {
    return loadPracticeRecord(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadPracticeRecord value)? loadPracticeRecord,
    TResult? Function(_refresh value)? refresh,
  }) {
    return loadPracticeRecord?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadPracticeRecord value)? loadPracticeRecord,
    TResult Function(_refresh value)? refresh,
    required TResult orElse(),
  }) {
    if (loadPracticeRecord != null) {
      return loadPracticeRecord(this);
    }
    return orElse();
  }
}

abstract class _LoadPracticeRecord implements PracticeHistoryEvent {
  const factory _LoadPracticeRecord() = _$LoadPracticeRecordImpl;
}

/// @nodoc
abstract class _$$refreshImplCopyWith<$Res> {
  factory _$$refreshImplCopyWith(
          _$refreshImpl value, $Res Function(_$refreshImpl) then) =
      __$$refreshImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$refreshImplCopyWithImpl<$Res>
    extends _$PracticeHistoryEventCopyWithImpl<$Res, _$refreshImpl>
    implements _$$refreshImplCopyWith<$Res> {
  __$$refreshImplCopyWithImpl(
      _$refreshImpl _value, $Res Function(_$refreshImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeHistoryEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$refreshImpl implements _refresh {
  const _$refreshImpl();

  @override
  String toString() {
    return 'PracticeHistoryEvent.refresh()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$refreshImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadPracticeRecord,
    required TResult Function() refresh,
  }) {
    return refresh();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadPracticeRecord,
    TResult? Function()? refresh,
  }) {
    return refresh?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadPracticeRecord,
    TResult Function()? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoadPracticeRecord value) loadPracticeRecord,
    required TResult Function(_refresh value) refresh,
  }) {
    return refresh(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_LoadPracticeRecord value)? loadPracticeRecord,
    TResult? Function(_refresh value)? refresh,
  }) {
    return refresh?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoadPracticeRecord value)? loadPracticeRecord,
    TResult Function(_refresh value)? refresh,
    required TResult orElse(),
  }) {
    if (refresh != null) {
      return refresh(this);
    }
    return orElse();
  }
}

abstract class _refresh implements PracticeHistoryEvent {
  const factory _refresh() = _$refreshImpl;
}

/// @nodoc
mixin _$PracticeHistoryState {
  int get currentPage => throw _privateConstructorUsedError;
  int get pageSize => throw _privateConstructorUsedError;
  bool get hasNext => throw _privateConstructorUsedError;
  List<RecordGroupList> get recordGroupList =>
      throw _privateConstructorUsedError;
  String? get selectedPracticeCategory => throw _privateConstructorUsedError;
  DateTime? get currentTime => throw _privateConstructorUsedError;

  /// Create a copy of PracticeHistoryState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PracticeHistoryStateCopyWith<PracticeHistoryState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PracticeHistoryStateCopyWith<$Res> {
  factory $PracticeHistoryStateCopyWith(PracticeHistoryState value,
          $Res Function(PracticeHistoryState) then) =
      _$PracticeHistoryStateCopyWithImpl<$Res, PracticeHistoryState>;
  @useResult
  $Res call(
      {int currentPage,
      int pageSize,
      bool hasNext,
      List<RecordGroupList> recordGroupList,
      String? selectedPracticeCategory,
      DateTime? currentTime});
}

/// @nodoc
class _$PracticeHistoryStateCopyWithImpl<$Res,
        $Val extends PracticeHistoryState>
    implements $PracticeHistoryStateCopyWith<$Res> {
  _$PracticeHistoryStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PracticeHistoryState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPage = null,
    Object? pageSize = null,
    Object? hasNext = null,
    Object? recordGroupList = null,
    Object? selectedPracticeCategory = freezed,
    Object? currentTime = freezed,
  }) {
    return _then(_value.copyWith(
      currentPage: null == currentPage
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      pageSize: null == pageSize
          ? _value.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int,
      hasNext: null == hasNext
          ? _value.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool,
      recordGroupList: null == recordGroupList
          ? _value.recordGroupList
          : recordGroupList // ignore: cast_nullable_to_non_nullable
              as List<RecordGroupList>,
      selectedPracticeCategory: freezed == selectedPracticeCategory
          ? _value.selectedPracticeCategory
          : selectedPracticeCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      currentTime: freezed == currentTime
          ? _value.currentTime
          : currentTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PracticeHistoryStateImplCopyWith<$Res>
    implements $PracticeHistoryStateCopyWith<$Res> {
  factory _$$PracticeHistoryStateImplCopyWith(_$PracticeHistoryStateImpl value,
          $Res Function(_$PracticeHistoryStateImpl) then) =
      __$$PracticeHistoryStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int currentPage,
      int pageSize,
      bool hasNext,
      List<RecordGroupList> recordGroupList,
      String? selectedPracticeCategory,
      DateTime? currentTime});
}

/// @nodoc
class __$$PracticeHistoryStateImplCopyWithImpl<$Res>
    extends _$PracticeHistoryStateCopyWithImpl<$Res, _$PracticeHistoryStateImpl>
    implements _$$PracticeHistoryStateImplCopyWith<$Res> {
  __$$PracticeHistoryStateImplCopyWithImpl(_$PracticeHistoryStateImpl _value,
      $Res Function(_$PracticeHistoryStateImpl) _then)
      : super(_value, _then);

  /// Create a copy of PracticeHistoryState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? currentPage = null,
    Object? pageSize = null,
    Object? hasNext = null,
    Object? recordGroupList = null,
    Object? selectedPracticeCategory = freezed,
    Object? currentTime = freezed,
  }) {
    return _then(_$PracticeHistoryStateImpl(
      currentPage: null == currentPage
          ? _value.currentPage
          : currentPage // ignore: cast_nullable_to_non_nullable
              as int,
      pageSize: null == pageSize
          ? _value.pageSize
          : pageSize // ignore: cast_nullable_to_non_nullable
              as int,
      hasNext: null == hasNext
          ? _value.hasNext
          : hasNext // ignore: cast_nullable_to_non_nullable
              as bool,
      recordGroupList: null == recordGroupList
          ? _value._recordGroupList
          : recordGroupList // ignore: cast_nullable_to_non_nullable
              as List<RecordGroupList>,
      selectedPracticeCategory: freezed == selectedPracticeCategory
          ? _value.selectedPracticeCategory
          : selectedPracticeCategory // ignore: cast_nullable_to_non_nullable
              as String?,
      currentTime: freezed == currentTime
          ? _value.currentTime
          : currentTime // ignore: cast_nullable_to_non_nullable
              as DateTime?,
    ));
  }
}

/// @nodoc

class _$PracticeHistoryStateImpl implements _PracticeHistoryState {
  const _$PracticeHistoryStateImpl(
      {this.currentPage = 0,
      this.pageSize = 0,
      this.hasNext = false,
      final List<RecordGroupList> recordGroupList = const [],
      this.selectedPracticeCategory = null,
      this.currentTime})
      : _recordGroupList = recordGroupList;

  @override
  @JsonKey()
  final int currentPage;
  @override
  @JsonKey()
  final int pageSize;
  @override
  @JsonKey()
  final bool hasNext;
  final List<RecordGroupList> _recordGroupList;
  @override
  @JsonKey()
  List<RecordGroupList> get recordGroupList {
    if (_recordGroupList is EqualUnmodifiableListView) return _recordGroupList;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_recordGroupList);
  }

  @override
  @JsonKey()
  final String? selectedPracticeCategory;
  @override
  final DateTime? currentTime;

  @override
  String toString() {
    return 'PracticeHistoryState(currentPage: $currentPage, pageSize: $pageSize, hasNext: $hasNext, recordGroupList: $recordGroupList, selectedPracticeCategory: $selectedPracticeCategory, currentTime: $currentTime)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PracticeHistoryStateImpl &&
            (identical(other.currentPage, currentPage) ||
                other.currentPage == currentPage) &&
            (identical(other.pageSize, pageSize) ||
                other.pageSize == pageSize) &&
            (identical(other.hasNext, hasNext) || other.hasNext == hasNext) &&
            const DeepCollectionEquality()
                .equals(other._recordGroupList, _recordGroupList) &&
            (identical(
                    other.selectedPracticeCategory, selectedPracticeCategory) ||
                other.selectedPracticeCategory == selectedPracticeCategory) &&
            (identical(other.currentTime, currentTime) ||
                other.currentTime == currentTime));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      currentPage,
      pageSize,
      hasNext,
      const DeepCollectionEquality().hash(_recordGroupList),
      selectedPracticeCategory,
      currentTime);

  /// Create a copy of PracticeHistoryState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PracticeHistoryStateImplCopyWith<_$PracticeHistoryStateImpl>
      get copyWith =>
          __$$PracticeHistoryStateImplCopyWithImpl<_$PracticeHistoryStateImpl>(
              this, _$identity);
}

abstract class _PracticeHistoryState implements PracticeHistoryState {
  const factory _PracticeHistoryState(
      {final int currentPage,
      final int pageSize,
      final bool hasNext,
      final List<RecordGroupList> recordGroupList,
      final String? selectedPracticeCategory,
      final DateTime? currentTime}) = _$PracticeHistoryStateImpl;

  @override
  int get currentPage;
  @override
  int get pageSize;
  @override
  bool get hasNext;
  @override
  List<RecordGroupList> get recordGroupList;
  @override
  String? get selectedPracticeCategory;
  @override
  DateTime? get currentTime;

  /// Create a copy of PracticeHistoryState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PracticeHistoryStateImplCopyWith<_$PracticeHistoryStateImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RecordGroupList {
  int get groupId => throw _privateConstructorUsedError;
  DateTime get exerciseDate => throw _privateConstructorUsedError;
  List<Exercise> get exercises => throw _privateConstructorUsedError;

  /// Create a copy of RecordGroupList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $RecordGroupListCopyWith<RecordGroupList> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecordGroupListCopyWith<$Res> {
  factory $RecordGroupListCopyWith(
          RecordGroupList value, $Res Function(RecordGroupList) then) =
      _$RecordGroupListCopyWithImpl<$Res, RecordGroupList>;
  @useResult
  $Res call({int groupId, DateTime exerciseDate, List<Exercise> exercises});
}

/// @nodoc
class _$RecordGroupListCopyWithImpl<$Res, $Val extends RecordGroupList>
    implements $RecordGroupListCopyWith<$Res> {
  _$RecordGroupListCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RecordGroupList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupId = null,
    Object? exerciseDate = null,
    Object? exercises = null,
  }) {
    return _then(_value.copyWith(
      groupId: null == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int,
      exerciseDate: null == exerciseDate
          ? _value.exerciseDate
          : exerciseDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      exercises: null == exercises
          ? _value.exercises
          : exercises // ignore: cast_nullable_to_non_nullable
              as List<Exercise>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$RecordGroupListImplCopyWith<$Res>
    implements $RecordGroupListCopyWith<$Res> {
  factory _$$RecordGroupListImplCopyWith(_$RecordGroupListImpl value,
          $Res Function(_$RecordGroupListImpl) then) =
      __$$RecordGroupListImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int groupId, DateTime exerciseDate, List<Exercise> exercises});
}

/// @nodoc
class __$$RecordGroupListImplCopyWithImpl<$Res>
    extends _$RecordGroupListCopyWithImpl<$Res, _$RecordGroupListImpl>
    implements _$$RecordGroupListImplCopyWith<$Res> {
  __$$RecordGroupListImplCopyWithImpl(
      _$RecordGroupListImpl _value, $Res Function(_$RecordGroupListImpl) _then)
      : super(_value, _then);

  /// Create a copy of RecordGroupList
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupId = null,
    Object? exerciseDate = null,
    Object? exercises = null,
  }) {
    return _then(_$RecordGroupListImpl(
      groupId: null == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int,
      exerciseDate: null == exerciseDate
          ? _value.exerciseDate
          : exerciseDate // ignore: cast_nullable_to_non_nullable
              as DateTime,
      exercises: null == exercises
          ? _value._exercises
          : exercises // ignore: cast_nullable_to_non_nullable
              as List<Exercise>,
    ));
  }
}

/// @nodoc

class _$RecordGroupListImpl implements _RecordGroupList {
  const _$RecordGroupListImpl(
      {required this.groupId,
      required this.exerciseDate,
      required final List<Exercise> exercises})
      : _exercises = exercises;

  @override
  final int groupId;
  @override
  final DateTime exerciseDate;
  final List<Exercise> _exercises;
  @override
  List<Exercise> get exercises {
    if (_exercises is EqualUnmodifiableListView) return _exercises;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_exercises);
  }

  @override
  String toString() {
    return 'RecordGroupList(groupId: $groupId, exerciseDate: $exerciseDate, exercises: $exercises)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$RecordGroupListImpl &&
            (identical(other.groupId, groupId) || other.groupId == groupId) &&
            (identical(other.exerciseDate, exerciseDate) ||
                other.exerciseDate == exerciseDate) &&
            const DeepCollectionEquality()
                .equals(other._exercises, _exercises));
  }

  @override
  int get hashCode => Object.hash(runtimeType, groupId, exerciseDate,
      const DeepCollectionEquality().hash(_exercises));

  /// Create a copy of RecordGroupList
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$RecordGroupListImplCopyWith<_$RecordGroupListImpl> get copyWith =>
      __$$RecordGroupListImplCopyWithImpl<_$RecordGroupListImpl>(
          this, _$identity);
}

abstract class _RecordGroupList implements RecordGroupList {
  const factory _RecordGroupList(
      {required final int groupId,
      required final DateTime exerciseDate,
      required final List<Exercise> exercises}) = _$RecordGroupListImpl;

  @override
  int get groupId;
  @override
  DateTime get exerciseDate;
  @override
  List<Exercise> get exercises;

  /// Create a copy of RecordGroupList
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$RecordGroupListImplCopyWith<_$RecordGroupListImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Exercise {
  int get exerciseId => throw _privateConstructorUsedError;
  List<Sets> get sets => throw _privateConstructorUsedError;
  double get prevBestWeight => throw _privateConstructorUsedError;
  int get prevBestReps => throw _privateConstructorUsedError;

  /// Create a copy of Exercise
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExerciseCopyWith<Exercise> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExerciseCopyWith<$Res> {
  factory $ExerciseCopyWith(Exercise value, $Res Function(Exercise) then) =
      _$ExerciseCopyWithImpl<$Res, Exercise>;
  @useResult
  $Res call(
      {int exerciseId,
      List<Sets> sets,
      double prevBestWeight,
      int prevBestReps});
}

/// @nodoc
class _$ExerciseCopyWithImpl<$Res, $Val extends Exercise>
    implements $ExerciseCopyWith<$Res> {
  _$ExerciseCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Exercise
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exerciseId = null,
    Object? sets = null,
    Object? prevBestWeight = null,
    Object? prevBestReps = null,
  }) {
    return _then(_value.copyWith(
      exerciseId: null == exerciseId
          ? _value.exerciseId
          : exerciseId // ignore: cast_nullable_to_non_nullable
              as int,
      sets: null == sets
          ? _value.sets
          : sets // ignore: cast_nullable_to_non_nullable
              as List<Sets>,
      prevBestWeight: null == prevBestWeight
          ? _value.prevBestWeight
          : prevBestWeight // ignore: cast_nullable_to_non_nullable
              as double,
      prevBestReps: null == prevBestReps
          ? _value.prevBestReps
          : prevBestReps // ignore: cast_nullable_to_non_nullable
              as int,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExerciseImplCopyWith<$Res>
    implements $ExerciseCopyWith<$Res> {
  factory _$$ExerciseImplCopyWith(
          _$ExerciseImpl value, $Res Function(_$ExerciseImpl) then) =
      __$$ExerciseImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {int exerciseId,
      List<Sets> sets,
      double prevBestWeight,
      int prevBestReps});
}

/// @nodoc
class __$$ExerciseImplCopyWithImpl<$Res>
    extends _$ExerciseCopyWithImpl<$Res, _$ExerciseImpl>
    implements _$$ExerciseImplCopyWith<$Res> {
  __$$ExerciseImplCopyWithImpl(
      _$ExerciseImpl _value, $Res Function(_$ExerciseImpl) _then)
      : super(_value, _then);

  /// Create a copy of Exercise
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? exerciseId = null,
    Object? sets = null,
    Object? prevBestWeight = null,
    Object? prevBestReps = null,
  }) {
    return _then(_$ExerciseImpl(
      exerciseId: null == exerciseId
          ? _value.exerciseId
          : exerciseId // ignore: cast_nullable_to_non_nullable
              as int,
      sets: null == sets
          ? _value._sets
          : sets // ignore: cast_nullable_to_non_nullable
              as List<Sets>,
      prevBestWeight: null == prevBestWeight
          ? _value.prevBestWeight
          : prevBestWeight // ignore: cast_nullable_to_non_nullable
              as double,
      prevBestReps: null == prevBestReps
          ? _value.prevBestReps
          : prevBestReps // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ExerciseImpl implements _Exercise {
  const _$ExerciseImpl(
      {required this.exerciseId,
      required final List<Sets> sets,
      required this.prevBestWeight,
      required this.prevBestReps})
      : _sets = sets;

  @override
  final int exerciseId;
  final List<Sets> _sets;
  @override
  List<Sets> get sets {
    if (_sets is EqualUnmodifiableListView) return _sets;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_sets);
  }

  @override
  final double prevBestWeight;
  @override
  final int prevBestReps;

  @override
  String toString() {
    return 'Exercise(exerciseId: $exerciseId, sets: $sets, prevBestWeight: $prevBestWeight, prevBestReps: $prevBestReps)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExerciseImpl &&
            (identical(other.exerciseId, exerciseId) ||
                other.exerciseId == exerciseId) &&
            const DeepCollectionEquality().equals(other._sets, _sets) &&
            (identical(other.prevBestWeight, prevBestWeight) ||
                other.prevBestWeight == prevBestWeight) &&
            (identical(other.prevBestReps, prevBestReps) ||
                other.prevBestReps == prevBestReps));
  }

  @override
  int get hashCode => Object.hash(runtimeType, exerciseId,
      const DeepCollectionEquality().hash(_sets), prevBestWeight, prevBestReps);

  /// Create a copy of Exercise
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExerciseImplCopyWith<_$ExerciseImpl> get copyWith =>
      __$$ExerciseImplCopyWithImpl<_$ExerciseImpl>(this, _$identity);
}

abstract class _Exercise implements Exercise {
  const factory _Exercise(
      {required final int exerciseId,
      required final List<Sets> sets,
      required final double prevBestWeight,
      required final int prevBestReps}) = _$ExerciseImpl;

  @override
  int get exerciseId;
  @override
  List<Sets> get sets;
  @override
  double get prevBestWeight;
  @override
  int get prevBestReps;

  /// Create a copy of Exercise
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExerciseImplCopyWith<_$ExerciseImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$Sets {
  int get set => throw _privateConstructorUsedError;
  double get weight => throw _privateConstructorUsedError;
  int get reps => throw _privateConstructorUsedError;
  double get score => throw _privateConstructorUsedError;
  double get strength => throw _privateConstructorUsedError;

  /// Create a copy of Sets
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SetsCopyWith<Sets> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SetsCopyWith<$Res> {
  factory $SetsCopyWith(Sets value, $Res Function(Sets) then) =
      _$SetsCopyWithImpl<$Res, Sets>;
  @useResult
  $Res call({int set, double weight, int reps, double score, double strength});
}

/// @nodoc
class _$SetsCopyWithImpl<$Res, $Val extends Sets>
    implements $SetsCopyWith<$Res> {
  _$SetsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of Sets
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? set = null,
    Object? weight = null,
    Object? reps = null,
    Object? score = null,
    Object? strength = null,
  }) {
    return _then(_value.copyWith(
      set: null == set
          ? _value.set
          : set // ignore: cast_nullable_to_non_nullable
              as int,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      reps: null == reps
          ? _value.reps
          : reps // ignore: cast_nullable_to_non_nullable
              as int,
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      strength: null == strength
          ? _value.strength
          : strength // ignore: cast_nullable_to_non_nullable
              as double,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SetsImplCopyWith<$Res> implements $SetsCopyWith<$Res> {
  factory _$$SetsImplCopyWith(
          _$SetsImpl value, $Res Function(_$SetsImpl) then) =
      __$$SetsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({int set, double weight, int reps, double score, double strength});
}

/// @nodoc
class __$$SetsImplCopyWithImpl<$Res>
    extends _$SetsCopyWithImpl<$Res, _$SetsImpl>
    implements _$$SetsImplCopyWith<$Res> {
  __$$SetsImplCopyWithImpl(_$SetsImpl _value, $Res Function(_$SetsImpl) _then)
      : super(_value, _then);

  /// Create a copy of Sets
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? set = null,
    Object? weight = null,
    Object? reps = null,
    Object? score = null,
    Object? strength = null,
  }) {
    return _then(_$SetsImpl(
      set: null == set
          ? _value.set
          : set // ignore: cast_nullable_to_non_nullable
              as int,
      weight: null == weight
          ? _value.weight
          : weight // ignore: cast_nullable_to_non_nullable
              as double,
      reps: null == reps
          ? _value.reps
          : reps // ignore: cast_nullable_to_non_nullable
              as int,
      score: null == score
          ? _value.score
          : score // ignore: cast_nullable_to_non_nullable
              as double,
      strength: null == strength
          ? _value.strength
          : strength // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$SetsImpl implements _Sets {
  const _$SetsImpl(
      {required this.set,
      required this.weight,
      required this.reps,
      required this.score,
      required this.strength});

  @override
  final int set;
  @override
  final double weight;
  @override
  final int reps;
  @override
  final double score;
  @override
  final double strength;

  @override
  String toString() {
    return 'Sets(set: $set, weight: $weight, reps: $reps, score: $score, strength: $strength)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SetsImpl &&
            (identical(other.set, set) || other.set == set) &&
            (identical(other.weight, weight) || other.weight == weight) &&
            (identical(other.reps, reps) || other.reps == reps) &&
            (identical(other.score, score) || other.score == score) &&
            (identical(other.strength, strength) ||
                other.strength == strength));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, set, weight, reps, score, strength);

  /// Create a copy of Sets
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SetsImplCopyWith<_$SetsImpl> get copyWith =>
      __$$SetsImplCopyWithImpl<_$SetsImpl>(this, _$identity);
}

abstract class _Sets implements Sets {
  const factory _Sets(
      {required final int set,
      required final double weight,
      required final int reps,
      required final double score,
      required final double strength}) = _$SetsImpl;

  @override
  int get set;
  @override
  double get weight;
  @override
  int get reps;
  @override
  double get score;
  @override
  double get strength;

  /// Create a copy of Sets
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SetsImplCopyWith<_$SetsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
